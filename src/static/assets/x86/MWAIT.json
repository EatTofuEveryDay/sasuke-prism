{"title":"MWAIT — Monitor Wait","fields":[{"name":"Instruction Modes","value":"`MWAIT`"},{"name":"Description","value":"MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitor and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction."},{"name":"\u200b","value":"CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode exception."},{"name":"\u200b","value":"This instruction’s operation is the same in non-64-bit modes and 64-bit mode."},{"name":"\u200b","value":"ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. The first processors to implement MWAIT supported only the zero value for EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT (see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor."},{"name":"C/C++ Intriniscs","value":"`MWAIT: void _mm_mwait(unsigned extensions, unsigned hints)\n`"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}