{"title":"CMPSS â€” Compare Scalar Single-Precision Floating-Point Value","fields":[{"name":"Instruction Modes","value":"`ib CMPSS xmm1, xmm2/m32, imm8`\n`ib VCMPSS xmm1, xmm2, xmm3/m32, imm8`\n`ib VCMPSS k1 {k2}, xmm2, xmm3/m32{sae}, imm8`"},{"name":"Description","value":"Compares the low single-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed."},{"name":"\u200b","value":"128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false)."},{"name":"\u200b","value":"VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 128:32 of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false)."},{"name":"\u200b","value":"EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared."},{"name":"\u200b","value":"The comparison predicate operand is an 8-bit immediate:"},{"name":"C/C++ Intrinsics","value":"`VCMPSS __mmask8 _mm_cmp_ss_mask( __m128 a, __m128 b, int imm);\n`"},{"name":"\u200b","value":"`VCMPSS __mmask8 _mm_cmp_round_ss_mask( __m128 a, __m128 b, int imm, int sae);\n`"},{"name":"\u200b","value":"`VCMPSS __mmask8 _mm_mask_cmp_ss_mask( __mmask8 k1, __m128 a, __m128 b, int imm);\n`"},{"name":"\u200b","value":"`VCMPSS __mmask8 _mm_mask_cmp_round_ss_mask( __mmask8 k1, __m128 a, __m128 b, int imm, int sae);\n`"},{"name":"\u200b","value":"`(V)CMPSS __m128 _mm_cmp_ss(__m128 a, __m128 b, const int imm)\n`"},{"name":"CPUID Flags","value":"SSE"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}