{"title":"MOVDQU/VMOVDQU8/VMOVDQU16/VMOVDQU32/VMOVDQU64 â€” Move Unaligned Packed Integer Values","fields":[{"name":"Instruction Modes","value":"`MOVDQU xmm1, xmm2/m128`\n`MOVDQU xmm2/m128, xmm1`\n`VMOVDQU xmm1, xmm2/m128`\n`VMOVDQU xmm2/m128, xmm1`\n`VMOVDQU ymm1, ymm2/m256`\n`VMOVDQU ymm2/m256, ymm1`\n`VMOVDQU8 xmm1 {k1}{z}, xmm2/m128`\n`VMOVDQU8 ymm1 {k1}{z}, ymm2/m256`\n`VMOVDQU8 zmm1 {k1}{z}, zmm2/m512`\n`VMOVDQU8 xmm2/m128 {k1}{z}, xmm1`\n`VMOVDQU8 ymm2/m256 {k1}{z}, ymm1`\n`VMOVDQU8 zmm2/m512 {k1}{z}, zmm1`\n`VMOVDQU16 xmm1 {k1}{z}, xmm2/m128`\n`VMOVDQU16 ymm1 {k1}{z}, ymm2/m256`\n`VMOVDQU16 zmm1 {k1}{z}, zmm2/m512`\n`VMOVDQU16 xmm2/m128 {k1}{z}, xmm1`\n`VMOVDQU16 ymm2/m256 {k1}{z}, ymm1`\n`VMOVDQU16 zmm2/m512 {k1}{z}, zmm1`\n`VMOVDQU32 xmm1 {k1}{z}, xmm2/mm128`\n`VMOVDQU32 ymm1 {k1}{z}, ymm2/m256`\n`VMOVDQU32 zmm1 {k1}{z}, zmm2/m512`\n`VMOVDQU32 xmm2/m128 {k1}{z}, xmm1`\n`VMOVDQU32 ymm2/m256 {k1}{z}, ymm1`\n`VMOVDQU32 zmm2/m512 {k1}{z}, zmm1`\n`VMOVDQU64 xmm1 {k1}{z}, xmm2/m128`\n`VMOVDQU64 ymm1 {k1}{z}, ymm2/m256`\n`VMOVDQU64 zmm1 {k1}{z}, zmm2/m512`\n`VMOVDQU64 xmm2/m128 {k1}{z}, xmm1`\n`VMOVDQU64 ymm2/m256 {k1}{z}, ymm1`\n`VMOVDQU64 zmm2/m512 {k1}{z}, zmm1`"},{"name":"Description","value":"Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."},{"name":"\u200b","value":"EVEX encoded versions:"},{"name":"\u200b","value":"Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers."},{"name":"\u200b","value":"The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask."},{"name":"\u200b","value":"VEX.256 encoded version:"},{"name":"\u200b","value":"Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers."},{"name":"\u200b","value":"Bits (MAXVL-1:256) of the destination register are zeroed."},{"name":"C/C++ Intriniscs","value":"`VMOVDQU16 __m512i _mm512_mask_loadu_epi16(__m512i s, __mmask32 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 __m512i _mm512_maskz_loadu_epi16( __mmask32 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 void _mm512_mask_storeu_epi16(void * d, __mmask32 k, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU16 __m256i _mm256_mask_loadu_epi16(__m256i s, __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 __m256i _mm256_maskz_loadu_epi16( __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 void _mm256_mask_storeu_epi16(void * d, __mmask16 k, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU16 __m128i _mm_mask_loadu_epi16(__m128i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 __m128i _mm_maskz_loadu_epi16( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU16 void _mm_mask_storeu_epi16(void * d, __mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m512i _mm512_loadu_epi32( void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m512i _mm512_mask_loadu_epi32(__m512i s, __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m512i _mm512_maskz_loadu_epi32( __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm512_storeu_epi32(void * d, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm512_mask_storeu_epi32(void * d, __mmask16 k, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m256i _mm256_mask_loadu_epi32(__m256i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m256i _mm256_maskz_loadu_epi32( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm256_storeu_epi32(void * d, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm256_mask_storeu_epi32(void * d, __mmask8 k, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m128i _mm_mask_loadu_epi32(__m128i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 __m128i _mm_maskz_loadu_epi32( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm_storeu_epi32(void * d, __m128i a);\n`"},{"name":"\u200b","value":"`VMOVDQU32 void _mm_mask_storeu_epi32(void * d, __mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m512i _mm512_loadu_epi64( void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m512i _mm512_mask_loadu_epi64(__m512i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m512i _mm512_maskz_loadu_epi64( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm512_storeu_epi64(void * d, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm512_mask_storeu_epi64(void * d, __mmask8 k, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m256i _mm256_mask_loadu_epi64(__m256i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m256i _mm256_maskz_loadu_epi64( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm256_storeu_epi64(void * d, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm256_mask_storeu_epi64(void * d, __mmask8 k, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m128i _mm_mask_loadu_epi64(__m128i s, __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 __m128i _mm_maskz_loadu_epi64( __mmask8 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm_storeu_epi64(void * d, __m128i a);\n`"},{"name":"\u200b","value":"`VMOVDQU64 void _mm_mask_storeu_epi64(void * d, __mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m512i _mm512_mask_loadu_epi8(__m512i s, __mmask64 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m512i _mm512_maskz_loadu_epi8( __mmask64 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 void _mm512_mask_storeu_epi8(void * d, __mmask64 k, __m512i a);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m256i _mm256_mask_loadu_epi8(__m256i s, __mmask32 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m256i _mm256_maskz_loadu_epi8( __mmask32 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 void _mm256_mask_storeu_epi8(void * d, __mmask32 k, __m256i a);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m128i _mm_mask_loadu_epi8(__m128i s, __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 __m128i _mm_maskz_loadu_epi8( __mmask16 k, void * sa);\n`"},{"name":"\u200b","value":"`VMOVDQU8 void _mm_mask_storeu_epi8(void * d, __mmask16 k, __m128i a);\n`"},{"name":"\u200b","value":"`MOVDQU __m256i _mm256_loadu_si256 (__m256i * p);\n`"},{"name":"\u200b","value":"`MOVDQU _mm256_storeu_si256(_m256i *p, __m256i a);\n`"},{"name":"\u200b","value":"`MOVDQU __m128i _mm_loadu_si128 (__m128i * p);\n`"},{"name":"\u200b","value":"`MOVDQU _mm_storeu_si128(__m128i *p, __m128i a);\n`"},{"name":"CPUID Flags","value":"SSE2"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}