{"title":"GF2P8AFFINEINVQB — Galois Field Affine Transformation Inverse","fields":[{"name":"Instruction Modes","value":"`/ib GF2P8AFFINEINVQB xmm1, xmm2/m128, imm8`"},{"name":"Description","value":"The AFFINEINVB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine transformation is defined by A * inv(x) + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. The inverse of the bytes in x is defined with respect to the reduction polynomial x8 + x4 + x3 + x + 1."},{"name":"\u200b","value":"One SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the first register. The “b” vector is constant for all calculations and contained in the immediate byte."},{"name":"\u200b","value":"The SSE encoded forms of the instruction require 16B alignment on their memory operations."},{"name":"\u200b","value":"The inverse of each byte is given by the following table. The upper nibble is on the vertical axis and the lower nibble is on the horizontal axis. For example, the inverse of 0x95 is 0x8A."},{"name":"C/C++ Intrinsics","value":"`GF2P8AFFINEINVQB __m128i _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);\n`"},{"name":"\u200b","value":"`GF2P8AFFINEINVQB __m128i _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);\n`"},{"name":"\u200b","value":"`GF2P8AFFINEINVQB __m128i _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);\n`"},{"name":"CPUID Flags","value":"GFNI"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}