{"title":"VRNDSCALEPD — Round Packed Float64 Values To Include A Given Number Of Fraction Bits","fields":[{"name":"Instruction Modes","value":"`ib VRNDSCALEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8`\n`ib VRNDSCALEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8`\n`ib VRNDSCALEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8`"},{"name":"Description","value":"Round the double-precision floating-point values in the source operand by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the destination operand."},{"name":"\u200b","value":"The destination operand (the first operand) is a ZMM/YMM/XMM register conditionally updated according to the writemask. The source operand (the second operand) can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location."},{"name":"\u200b","value":"The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a double-precision floating-point value."},{"name":"\u200b","value":"It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value)."},{"name":"\u200b","value":"The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field)."},{"name":"\u200b","value":"The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding."},{"name":"\u200b","value":"The sign of the result of this instruction is preserved, including the sign of zero."},{"name":"\u200b","value":"The formula of the operation on each data element for VRNDSCALEPD is"},{"name":"\u200b","value":"ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"M=imm[7:4];"},{"name":"\u200b","value":"The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs)."},{"name":"\u200b","value":"VRNDSCALEPD is a more general form of the VEX-encoded VROUNDPD instruction. In VROUNDPD, the formula of the operation on each element is"},{"name":"\u200b","value":"ROUND(x) = Round_to_INT(x, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`VRNDSCALEPD __m512d _mm512_roundscale_pd( __m512d a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPD __m512d _mm512_roundscale_round_pd( __m512d a, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALEPD __m512d _mm512_mask_roundscale_pd(__m512d s, __mmask8 k, __m512d a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPD __m512d _mm512_mask_roundscale_round_pd(__m512d s, __mmask8 k, __m512d a, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALEPD __m512d _mm512_maskz_roundscale_pd( __mmask8 k, __m512d a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPD __m512d _mm512_maskz_roundscale_round_pd( __mmask8 k, __m512d a, int imm, int sae);\n`"},{"name":"\u200b","value":"(6 more)"},{"name":"CPUID Flags","value":"AVX512VL AVX512F"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}