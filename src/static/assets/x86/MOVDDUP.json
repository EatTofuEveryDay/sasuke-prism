{"title":"MOVDDUP â€” Replicate Double FP Values","fields":[{"name":"Instruction Modes","value":"`MOVDDUP xmm1, xmm2/m64`\n`VMOVDDUP xmm1, xmm2/m64`\n`VMOVDDUP ymm1, ymm2/m256`\n`VMOVDDUP xmm1 {k1}{z}, xmm2/m64`\n`VMOVDDUP ymm1 {k1}{z}, ymm2/m256`\n`VMOVDDUP zmm1 {k1}{z}, zmm2/m512`"},{"name":"Description","value":"For 256-bit or higher versions: Duplicates even-indexed double-precision floating-point values from the source operand (the second operand) and into adjacent pair and store to the destination operand (the first operand)."},{"name":"\u200b","value":"For 128-bit versions: Duplicates the low double-precision floating-point value from the source operand (the second operand) and store to the destination operand (the first operand)."},{"name":"\u200b","value":"128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register are unchanged. The source operand is XMM register or a 64-bit memory location."},{"name":"\u200b","value":"VEX.128 and EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. The source operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask for EVEX version."},{"name":"\u200b","value":"VEX.256 and EVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed. The source operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the writemask for EVEX version."},{"name":"\u200b","value":"EVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM register or a 512-bit memory location."},{"name":"\u200b","value":"Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`VMOVDDUP __m512d _mm512_movedup_pd( __m512d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m512d _mm512_mask_movedup_pd(__m512d s, __mmask8 k, __m512d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m512d _mm512_maskz_movedup_pd( __mmask8 k, __m512d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m256d _mm256_mask_movedup_pd(__m256d s, __mmask8 k, __m256d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m256d _mm256_maskz_movedup_pd( __mmask8 k, __m256d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m128d _mm_mask_movedup_pd(__m128d s, __mmask8 k, __m128d a);\n`"},{"name":"\u200b","value":"`VMOVDDUP __m128d _mm_maskz_movedup_pd( __mmask8 k, __m128d a);\n`"},{"name":"\u200b","value":"`MOVDDUP __m256d _mm256_movedup_pd (__m256d a);\n`"},{"name":"\u200b","value":"`MOVDDUP __m128d _mm_movedup_pd (__m128d a);\n`"},{"name":"CPUID Flags","value":"SSE3"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}