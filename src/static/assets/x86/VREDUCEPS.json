{"title":"VREDUCEPS — Perform Reduction Transformation on Packed Float32 Values","fields":[{"name":"Instruction Modes","value":"`ib VREDUCEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8`\n`ib VREDUCEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8`\n`ib VREDUCEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8`"},{"name":"Description","value":"Perform reduction transformation of the packed binary encoded single-precision FP values in the source operand (the second operand) and store the reduced results in binary FP format to the destination operand (the first operand) under the writemask k1."},{"name":"\u200b","value":"The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:"},{"name":"\u200b","value":"dest = src – (ROUND(2M*src))*2-M;"},{"name":"\u200b","value":"where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents."},{"name":"\u200b","value":"The magnitude of the reduced result can be expressed by considering src= 2p*man2,"},{"name":"\u200b","value":"where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent"},{"name":"\u200b","value":"Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1"},{"name":"\u200b","value":"Then if RC ≠ RNE: 0&lt;=|Reduced Result|&lt;2p-M"},{"name":"\u200b","value":"This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported."},{"name":"\u200b","value":"EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."},{"name":"\u200b","value":"Handling of special case of input values are listed in Table 5-24."},{"name":"C/C++ Intrinsics","value":"`VREDUCEPS __m512 _mm512_mask_reduce_ps( __m512 a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m512 _mm512_mask_reduce_ps(__m512 s, __mmask16 k, __m512 a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m512 _mm512_maskz_reduce_ps(__mmask16 k, __m512 a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m256 _mm256_mask_reduce_ps( __m256 a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m256 _mm256_mask_reduce_ps(__m256 s, __mmask8 k, __m256 a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m256 _mm256_maskz_reduce_ps(__mmask8 k, __m256 a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m128 _mm_mask_reduce_ps( __m128 a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m128 _mm_mask_reduce_ps(__m128 s, __mmask8 k, __m128 a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPS __m128 _mm_maskz_reduce_ps(__mmask8 k, __m128 a, int imm)\n`"},{"name":"CPUID Flags","value":"AVX512VL AVX512DQ"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}