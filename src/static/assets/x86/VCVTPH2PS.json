{"title":"VCVTPH2PS â€” Convert 16-bit FP values to Single-Precision FP values","fields":[{"name":"Instruction Modes","value":"`VCVTPH2PS xmm1, xmm2/m64`\n`VCVTPH2PS ymm1, xmm2/m128`\n`VCVTPH2PS xmm1 {k1}{z}, xmm2/m64`\n`VCVTPH2PS ymm1 {k1}{z}, xmm2/m128`\n`VCVTPH2PS zmm1 {k1}{z}, ymm2/m256 {sae}`"},{"name":"Description","value":"Converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the second operand) to packed single-precision floating-point values and writes the converted values into the destination operand (the first operand)."},{"name":"\u200b","value":"If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR."},{"name":"\u200b","value":"VEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register are zeroed."},{"name":"\u200b","value":"VEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination register are zeroed."},{"name":"\u200b","value":"EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."},{"name":"\u200b","value":"The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single precision (in 128 bits) FP values."},{"name":"\u200b","value":"Note: VEX.vvvv and EVEX.vvvv are reserved (must be 1111b)."},{"name":"C/C++ Intrinsics","value":"`VCVTPH2PS __m512 _mm512_cvtph_ps( __m256i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m512 _mm512_mask_cvtph_ps(__m512 s, __mmask16 k, __m256i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m512 _mm512_maskz_cvtph_ps(__mmask16 k, __m256i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m512 _mm512_cvt_roundph_ps( __m256i a, int sae);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m512 _mm512_mask_cvt_roundph_ps(__m512 s, __mmask16 k, __m256i a, int sae);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m512 _mm512_maskz_cvt_roundph_ps( __mmask16 k, __m256i a, int sae);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m256 _mm256_mask_cvtph_ps(__m256 s, __mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m256 _mm256_maskz_cvtph_ps(__mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m128 _mm_mask_cvtph_ps(__m128 s, __mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m128 _mm_maskz_cvtph_ps(__mmask8 k, __m128i a);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m128 _mm_cvtph_ps ( __m128i m1);\n`"},{"name":"\u200b","value":"`VCVTPH2PS __m256 _mm256_cvtph_ps ( __m128i m1)\n`"},{"name":"CPUID Flags","value":"F16C"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}