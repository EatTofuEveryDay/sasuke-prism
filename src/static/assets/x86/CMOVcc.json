{"title":"CMOVcc — Conditional Move","fields":[{"name":"Instruction Modes","value":"`CMOVA r16, r/m16`\n`CMOVA r32, r/m32`\n`CMOVA r64, r/m64`\n`CMOVAE r16, r/m16`\n`CMOVAE r32, r/m32`\n`CMOVAE r64, r/m64`\n`CMOVB r16, r/m16`\n`CMOVB r32, r/m32`\n`CMOVB r64, r/m64`\n`CMOVBE r16, r/m16`\n`CMOVBE r32, r/m32`\n`CMOVBE r64, r/m64`\n`CMOVC r16, r/m16`\n`CMOVC r32, r/m32`\n`CMOVC r64, r/m64`\n`CMOVE r16, r/m16`\n`CMOVE r32, r/m32`\n`CMOVE r64, r/m64`\n`CMOVG r16, r/m16`\n`CMOVG r32, r/m32`\n`CMOVG r64, r/m64`\n`CMOVGE r16, r/m16`\n`CMOVGE r32, r/m32`\n`CMOVGE r64, r/m64`\n`CMOVL r16, r/m16`\n`CMOVL r32, r/m32`\n`CMOVL r64, r/m64`\n`CMOVLE r16, r/m16`\n`CMOVLE r32, r/m32`\n`CMOVLE r64, r/m64`\n`CMOVNA r16, r/m16`\n`CMOVNA r32, r/m32`\n`CMOVNA r64, r/m64`\n`CMOVNAE r16, r/m16`\n`CMOVNAE r32, r/m32`\n`CMOVNAE r64, r/m64`\n`CMOVNB r16, r/m16`\n`CMOVNB r32, r/m32`\n`CMOVNB r64, r/m64`\n`CMOVNBE r16, r/m16`\n`CMOVNBE r32, r/m32`\n`CMOVNBE r64, r/m64`\n`CMOVNC r16, r/m16`\n`CMOVNC r32, r/m32`\n`CMOVNC r64, r/m64`\n`CMOVNE r16, r/m16`\n`CMOVNE r32, r/m32`\n`CMOVNE r64, r/m64`\n`CMOVNG r16, r/m16`\n`CMOVNG r32, r/m32`\n`CMOVNG r64, r/m64`\n`CMOVNGE r16, r/m16`\n`CMOVNGE r32, r/m32`\n`CMOVNGE r64, r/m64`\n`CMOVNL r16, r/m16`\n`CMOVNL r32, r/m32`\n`CMOVNL r64, r/m64`\n`CMOVNLE r16, r/m16`\n`CMOVNLE r32, r/m32`\n`CMOVNLE r64, r/m64`\n`CMOVNO r16, r/m16`\n`CMOVNO r32, r/m32`\n`CMOVNO r64, r/m64`\n`CMOVNP r16, r/m16`\n`CMOVNP r32, r/m32`\n`CMOVNP r64, r/m64`\n`CMOVNS r16, r/m16`\n`CMOVNS r32, r/m32`\n`CMOVNS r64, r/m64`\n`CMOVNZ r16, r/m16`\n`CMOVNZ r32, r/m32`\n`CMOVNZ r64, r/m64`\n`CMOVO r16, r/m16`\n`CMOVO r32, r/m32`\n`CMOVO r64, r/m64`\n`CMOVP r16, r/m16`\n`CMOVP r32, r/m32`\n`CMOVP r64, r/m64`\n`CMOVPE r16, r/m16`\n`CMOVPE r32, r/m32`\n`CMOVPE r64, r/m64`\n`CMOVPO r16, r/m16`\n`CMOVPO r32, r/m32`\n`CMOVPO r64, r/m64`\n`CMOVS r16, r/m16`\n`CMOVS r32, r/m32`\n`CMOVS r64, r/m64`\n`CMOVZ r16, r/m16`\n`CMOVZ r32, r/m32`\n`CMOVZ r64, r/m64`"},{"name":"Description","value":"The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction."},{"name":"\u200b","value":"These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported."},{"name":"\u200b","value":"The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers."},{"name":"\u200b","value":"Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H."},{"name":"\u200b","value":"The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter)."},{"name":"\u200b","value":"In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits."}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}