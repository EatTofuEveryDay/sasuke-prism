{"title":"PCMPISTRI — Packed Compare Implicit Length Strings, Return Index","fields":[{"name":"Instruction Modes","value":"`imm8 PCMPISTRI xmm1, xmm2/m128, imm8`\n`ib VPCMPISTRI xmm1, xmm2/m128, imm8`"},{"name":"Description","value":"The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX."},{"name":"\u200b","value":"Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)"},{"name":"\u200b","value":"The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8)."},{"name":"\u200b","value":"Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:"},{"name":"\u200b","value":"CFlag – Reset if IntRes2 is equal to zero, set otherwise"},{"name":"\u200b","value":"ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise"},{"name":"\u200b","value":"SFlag – Set if any byte/word of xmm1 is null, reset otherwise"},{"name":"\u200b","value":"OFlag –IntRes2[0]"},{"name":"\u200b","value":"AFlag – Reset"},{"name":"\u200b","value":"PFlag – Reset"},{"name":"\u200b","value":"Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."},{"name":"CPUID Flags","value":"SSE4_2"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}