{"title":"VSCATTERDPS/VSCATTERDPD/VSCATTERQPS/VSCATTERQPD â€” Scatter Packed Single, Packed Double with Signed Dword and Qword Indices","fields":[{"name":"Instruction Modes","value":"`VSCATTERDPS vm32x {k1}, xmm1`\n`VSCATTERDPS vm32y {k1}, ymm1`\n`VSCATTERDPS vm32z {k1}, zmm1`\n`VSCATTERDPD vm32x {k1}, xmm1`\n`VSCATTERDPD vm32x {k1}, ymm1`\n`VSCATTERDPD vm32y {k1}, zmm1`\n`VSCATTERQPS vm64x {k1}, xmm1`\n`VSCATTERQPS vm64y {k1}, xmm1`\n`VSCATTERQPS vm64z {k1}, ymm1`\n`VSCATTERQPD vm64x {k1}, xmm1`\n`VSCATTERQPD vm64y {k1}, ymm1`\n`VSCATTERQPD vm64z {k1}, zmm1`"},{"name":"Description","value":"Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception."},{"name":"\u200b","value":"This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued."},{"name":"\u200b","value":"Note that:"},{"name":"C/C++ Intrinsics","value":"`VSCATTERDPD void _mm512_i32scatter_pd(void * base, __m256i vdx, __m512d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPD void _mm512_mask_i32scatter_pd(void * base, __mmask8 k, __m256i vdx, __m512d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPS void _mm512_i32scatter_ps(void * base, __m512i vdx, __m512 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPS void _mm512_mask_i32scatter_ps(void * base, __mmask16 k, __m512i vdx, __m512 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPD void _mm512_i64scatter_pd(void * base, __m512i vdx, __m512d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPD void _mm512_mask_i64scatter_pd(void * base, __mmask8 k, __m512i vdx, __m512d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPS void _mm512_i64scatter_ps(void * base, __m512i vdx, __m256 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPS void _mm512_mask_i64scatter_ps(void * base, __mmask8 k, __m512i vdx, __m256 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPD void _mm256_i32scatter_pd(void * base, __m128i vdx, __m256d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPD void _mm256_mask_i32scatter_pd(void * base, __mmask8 k, __m128i vdx, __m256d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPS void _mm256_i32scatter_ps(void * base, __m256i vdx, __m256 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPS void _mm256_mask_i32scatter_ps(void * base, __mmask8 k, __m256i vdx, __m256 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPD void _mm256_i64scatter_pd(void * base, __m256i vdx, __m256d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPD void _mm256_mask_i64scatter_pd(void * base, __mmask8 k, __m256i vdx, __m256d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPS void _mm256_i64scatter_ps(void * base, __m256i vdx, __m128 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERQPS void _mm256_mask_i64scatter_ps(void * base, __mmask8 k, __m256i vdx, __m128 a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPD void _mm_i32scatter_pd(void * base, __m128i vdx, __m128d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPD void _mm_mask_i32scatter_pd(void * base, __mmask8 k, __m128i vdx, __m128d a, int scale);\n`"},{"name":"\u200b","value":"`VSCATTERDPS void _mm_i32scatter_ps(void * base, __m128i vdx, __m128 a, int scale);\n`"},{"name":"\u200b","value":"(5 more)"},{"name":"CPUID Flags","value":"AVX512VL AVX512F"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}