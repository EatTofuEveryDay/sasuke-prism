{"title":"VPCONFLICTD/VPCONFLICTQ — Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register","fields":[{"name":"Instruction Modes","value":"`VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst`\n`VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst`\n`VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst`\n`VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst`\n`VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst`\n`VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst`"},{"name":"Description","value":"Test each dword/qword element of the source operand (the second operand) for equality with all other elements in the source operand closer to the least significant element. Each element’s comparison results form a bit vector, which is then zero extended and written to the destination according to the writemask."},{"name":"\u200b","value":"EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1."},{"name":"\u200b","value":"EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1."},{"name":"\u200b","value":"EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."},{"name":"\u200b","value":"EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`VPCONFLICTD __m512i _mm512_conflict_epi32( __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m512i _mm512_mask_conflict_epi32(__m512i s, __mmask16 m, __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m512i _mm512_maskz_conflict_epi32(__mmask16 m, __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m512i _mm512_conflict_epi64( __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m512i _mm512_mask_conflict_epi64(__m512i s, __mmask8 m, __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m512i _mm512_maskz_conflict_epi64(__mmask8 m, __m512i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m256i _mm256_conflict_epi32( __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m256i _mm256_mask_conflict_epi32(__m256i s, __mmask8 m, __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m256i _mm256_maskz_conflict_epi32(__mmask8 m, __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m256i _mm256_conflict_epi64( __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m256i _mm256_mask_conflict_epi64(__m256i s, __mmask8 m, __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m256i _mm256_maskz_conflict_epi64(__mmask8 m, __m256i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m128i _mm_conflict_epi32( __m128i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m128i _mm_mask_conflict_epi32(__m128i s, __mmask8 m, __m128i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTD __m128i _mm_maskz_conflict_epi32(__mmask8 m, __m128i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m128i _mm_conflict_epi64( __m128i a);\n`"},{"name":"\u200b","value":"`VPCONFLICTQ __m128i _mm_mask_conflict_epi64(__m128i s, __mmask8 m, __m128i a);\n`"},{"name":"\u200b","value":"(1 more)"},{"name":"CPUID Flags","value":"AVX512VL AVX512CD"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}