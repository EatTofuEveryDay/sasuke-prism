{"title":"LDDQU â€” Load Unaligned Integer 128 Bits","fields":[{"name":"Instruction Modes","value":"`LDDQU xmm1, mem`\n`VLDDQU xmm1, m128`\n`VLDDQU ymm1, m256`"},{"name":"Description","value":"The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent."},{"name":"\u200b","value":"This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction."},{"name":"C/C++ Intriniscs","value":"`LDDQU: __m128i _mm_lddqu_si128 (__m128i * p);\n`"},{"name":"\u200b","value":"`VLDDQU: __m256i _mm256_lddqu_si256 (__m256i * p);\n`"},{"name":"CPUID Flags","value":"SSE3"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}