{"title":"PALIGNR â€” Packed Align Right","fields":[{"name":"Instruction Modes","value":"`ib1 PALIGNR mm1, mm2/m64, imm8`\n`ib PALIGNR xmm1, xmm2/m128, imm8`\n`ib VPALIGNR xmm1, xmm2, xmm3/m128, imm8`\n`ib VPALIGNR ymm1, ymm2, ymm3/m256, imm8`\n`ib VPALIGNR xmm1 {k1}{z}, xmm2, xmm3/m128, imm8`\n`ib VPALIGNR ymm1 {k1}{z}, ymm2, ymm3/m256, imm8`\n`ib VPALIGNR zmm1 {k1}{z}, zmm2, zmm3/m512, imm8`"},{"name":"Description","value":"(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant immediate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,"},{"name":"\u200b","value":"XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX registers, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},{"name":"\u200b","value":"In 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers."},{"name":"\u200b","value":"128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged."},{"name":"\u200b","value":"EVEX.512 encoded version: The first source operand is a ZMM register and contains four 16-byte blocks. The second source operand is a ZMM register or a 512-bit memory location containing four 16-byte block. The destination operand is a ZMM register and contain four 16-byte results. The imm8[7:0] is the common shift count"},{"name":"\u200b","value":"used for each of the four successive 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand and so on for the blocks in the middle."},{"name":"\u200b","value":"VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed."},{"name":"\u200b","value":"VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed."},{"name":"\u200b","value":"Concatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand."},{"name":"\u200b","value":"Note: VEX.L must be 0, otherwise the instruction will #UD."},{"name":"\u200b","value":"0 127 0 127"},{"name":"CPUID Flags","value":"SSSE3"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}