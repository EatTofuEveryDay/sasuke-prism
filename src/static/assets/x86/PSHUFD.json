{"title":"PSHUFD â€” Shuffle Packed Doublewords","fields":[{"name":"Instruction Modes","value":"`ib PSHUFD xmm1, xmm2/m128, imm8`\n`ib VPSHUFD xmm1, xmm2/m128, imm8`\n`ib VPSHUFD ymm1, ymm2/m256, imm8`\n`ib VPSHUFD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8`\n`ib VPSHUFD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8`\n`ib VPSHUFD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8`"},{"name":"Description","value":"Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand."},{"name":"\u200b","value":"For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand."},{"name":"C/C++ Intriniscs","value":"`VPSHUFD __m512i _mm512_shuffle_epi32(__m512i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m512i _mm512_mask_shuffle_epi32(__m512i s, __mmask16 k, __m512i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m512i _mm512_maskz_shuffle_epi32( __mmask16 k, __m512i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m256i _mm256_mask_shuffle_epi32(__m256i s, __mmask8 k, __m256i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m256i _mm256_maskz_shuffle_epi32( __mmask8 k, __m256i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m128i _mm_mask_shuffle_epi32(__m128i s, __mmask8 k, __m128i a, int n );\n`"},{"name":"\u200b","value":"`VPSHUFD __m128i _mm_maskz_shuffle_epi32( __mmask8 k, __m128i a, int n );\n`"},{"name":"\u200b","value":"`(V)PSHUFD:__m128i _mm_shuffle_epi32(__m128i a, int n)\n`"},{"name":"\u200b","value":"`VPSHUFD:__m256i _mm256_shuffle_epi32(__m256i a, const int n)\n`"},{"name":"CPUID Flags","value":"SSE2"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}