{"title":"CMPSD â€” Compare Scalar Double-Precision Floating-Point Value","fields":[{"name":"Instruction Modes","value":"`ib CMPSD xmm1, xmm2/m64, imm8`\n`ib VCMPSD xmm1, xmm2, xmm3/m64, imm8`\n`ib VCMPSD k1 {k2}, xmm2, xmm3/m64{sae}, imm8`"},{"name":"Description","value":"Compares the low double-precision floating-point values in the second source operand and the first source operand and returns the results in of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed."},{"name":"\u200b","value":"128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false)."},{"name":"\u200b","value":"VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 64-bit memory location. The result is stored in the low quadword of the destination operand; the high quadword is filled with the contents of the high quadword of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false)."},{"name":"\u200b","value":"EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 64-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared."},{"name":"\u200b","value":"The comparison predicate operand is an 8-bit immediate:"},{"name":"C/C++ Intrinsics","value":"`VCMPSD __mmask8 _mm_cmp_sd_mask( __m128d a, __m128d b, int imm);\n`"},{"name":"\u200b","value":"`VCMPSD __mmask8 _mm_cmp_round_sd_mask( __m128d a, __m128d b, int imm, int sae);\n`"},{"name":"\u200b","value":"`VCMPSD __mmask8 _mm_mask_cmp_sd_mask( __mmask8 k1, __m128d a, __m128d b, int imm);\n`"},{"name":"\u200b","value":"`VCMPSD __mmask8 _mm_mask_cmp_round_sd_mask( __mmask8 k1, __m128d a, __m128d b, int imm, int sae);\n`"},{"name":"\u200b","value":"`(V)CMPSD __m128d _mm_cmp_sd(__m128d a, __m128d b, const int imm)\n`"},{"name":"CPUID Flags","value":"SSE2"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}