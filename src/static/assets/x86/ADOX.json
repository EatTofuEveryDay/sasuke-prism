{"title":"ADOX — Unsigned Integer Addition of Two Operands with Overflow Flag","fields":[{"name":"Instruction Modes","value":"`ADOX r32, r/m32`\n`ADOX r64, r/m64`"},{"name":"Description","value":"Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands."},{"name":"\u200b","value":"The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR)."},{"name":"\u200b","value":"This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode."},{"name":"\u200b","value":"In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits."},{"name":"\u200b","value":"ADOX executes normally either inside or outside a transaction region."},{"name":"\u200b","value":"Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A."},{"name":"C/C++ Intriniscs","value":"`unsigned char _addcarryx_u32 (unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum_out);\n`"},{"name":"\u200b","value":"`unsigned char _addcarryx_u64 (unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);\n`"},{"name":"CPUID Flags","value":"ADX"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}