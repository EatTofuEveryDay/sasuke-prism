{"title":"CVTSD2SI â€” Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer","fields":[{"name":"Instruction Modes","value":"`CVTSD2SI r32, xmm1/m64`\n`CVTSD2SI r64, xmm1/m64`\n`1 VCVTSD2SI r32, xmm1/m64`\n`1 VCVTSD2SI r64, xmm1/m64`\n`VCVTSD2SI r32, xmm1/m64{er}`\n`VCVTSD2SI r64, xmm1/m64{er}`"},{"name":"Description","value":"Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-word integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register."},{"name":"\u200b","value":"When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register."},{"name":"\u200b","value":"If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned."},{"name":"\u200b","value":"If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned."},{"name":"\u200b","value":"Legacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode. See the summary chart at the beginning of this section for encoding data and limits."},{"name":"\u200b","value":"Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."},{"name":"\u200b","value":"Software should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."},{"name":"C/C++ Intriniscs","value":"`VCVTSD2SI int _mm_cvtsd_i32(__m128d);\n`"},{"name":"\u200b","value":"`VCVTSD2SI int _mm_cvt_roundsd_i32(__m128d, int r);\n`"},{"name":"\u200b","value":"`VCVTSD2SI __int64 _mm_cvtsd_i64(__m128d);\n`"},{"name":"\u200b","value":"`VCVTSD2SI __int64 _mm_cvt_roundsd_i64(__m128d, int r);\n`"},{"name":"\u200b","value":"`CVTSD2SI __int64 _mm_cvtsd_si64(__m128d);\n`"},{"name":"\u200b","value":"`CVTSD2SI int _mm_cvtsd_si32(__m128d a)\n`"},{"name":"CPUID Flags","value":"SSE2"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}