{"title":"VRNDSCALESS — Round Scalar Float32 Value To Include A Given Number Of Fraction Bits","fields":[{"name":"Instruction Modes","value":"`ib VRNDSCALESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8`"},{"name":"Description","value":"Rounds the single-precision floating-point value in the low doubleword element of the second source operand (the third operand) by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the corresponding element of the destination operand (the first operand) according to the writemask. The double-word elements at bits 127:32 of the destination are copied from the first source operand (the second operand)."},{"name":"\u200b","value":"The destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or memory location. Bits MAXVL-1:128 of the destination register are cleared."},{"name":"\u200b","value":"The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value."},{"name":"\u200b","value":"It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value)."},{"name":"\u200b","value":"The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control tables below lists the encoded values for rounding-mode field)."},{"name":"\u200b","value":"The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding."},{"name":"\u200b","value":"The sign of the result of this instruction is preserved, including the sign of zero."},{"name":"\u200b","value":"The formula of the operation for VRNDSCALESS is"},{"name":"\u200b","value":"ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"M=imm[7:4];"},{"name":"\u200b","value":"The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs)."},{"name":"\u200b","value":"VRNDSCALESS is a more general form of the VEX-encoded VROUNDSS instruction. In VROUNDSS, the formula of the operation on each element is"},{"name":"\u200b","value":"ROUND(x) = Round_to_INT(x, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"EVEX encoded version: The source operand is a XMM register or a 32-bit memory location. The destination operand is a XMM register."},{"name":"\u200b","value":"Handling of special case of input values are listed in Table 5-25."},{"name":"C/C++ Intriniscs","value":"`VRNDSCALESS __m128 _mm_roundscale_ss ( __m128 a, __m128 b, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALESS __m128 _mm_roundscale_round_ss ( __m128 a, __m128 b, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALESS __m128 _mm_mask_roundscale_ss (__m128 s, __mmask8 k, __m128 a, __m128 b, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALESS __m128 _mm_mask_roundscale_round_ss (__m128 s, __mmask8 k, __m128 a, __m128 b, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALESS __m128 _mm_maskz_roundscale_ss ( __mmask8 k, __m128 a, __m128 b, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALESS __m128 _mm_maskz_roundscale_round_ss ( __mmask8 k, __m128 a, __m128 b, int imm, int sae);\n`"},{"name":"CPUID Flags","value":"AVX512F"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}