{"title":"Jcc — Jump if Condition Is Met","fields":[{"name":"Instruction Modes","value":"`JA rel8`\n`JAE rel8`\n`JB rel8`\n`JBE rel8`\n`JC rel8`\n`JCXZ rel8`\n`JECXZ rel8`\n`JRCXZ rel8`\n`JE rel8`\n`JG rel8`\n`JGE rel8`\n`JL rel8`\n`JLE rel8`\n`JNA rel8`\n`JNAE rel8`\n`JNB rel8`\n`JNBE rel8`\n`JNC rel8`\n`JNE rel8`\n`JNG rel8`\n`JNGE rel8`\n`JNL rel8`\n`JNLE rel8`\n`JNO rel8`\n`JNP rel8`\n`JNS rel8`\n`JNZ rel8`\n`JO rel8`\n`JP rel8`\n`JPE rel8`\n`JPO rel8`\n`JS rel8`\n`JZ rel8`\n`JA rel16`\n`JA rel32`\n`JAE rel16`\n`JAE rel32`\n`JB rel16`\n`JB rel32`\n`JBE rel16`\n`JBE rel32`\n`JC rel16`\n`JC rel32`\n`JE rel16`\n`JE rel32`\n`JZ rel16`\n`JZ rel32`\n`JG rel16`\n`JG rel32`\n`JGE rel16`\n`JGE rel32`\n`JL rel16`\n`JL rel32`\n`JLE rel16`\n`JLE rel32`\n`JNA rel16`\n`JNA rel32`\n`JNAE rel16`\n`JNAE rel32`\n`JNB rel16`\n`JNB rel32`\n`JNBE rel16`\n`JNBE rel32`\n`JNC rel16`\n`JNC rel32`\n`JNE rel16`\n`JNE rel32`\n`JNG rel16`\n`JNG rel32`\n`JNGE rel16`\n`JNGE rel32`\n`JNL rel16`\n`JNL rel32`\n`JNLE rel16`\n`JNLE rel32`\n`JNO rel16`\n`JNO rel32`\n`JNP rel16`\n`JNP rel32`\n`JNS rel16`\n`JNS rel32`\n`JNZ rel16`\n`JNZ rel32`\n`JO rel16`\n`JO rel32`\n`JP rel16`\n`JP rel32`\n`JPE rel16`\n`JPE rel32`\n`JPO rel16`\n`JPO rel32`\n`JS rel16`\n`JS rel32`\n`JZ rel16`\n`JZ rel32`"},{"name":"Description","value":"Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction."},{"name":"\u200b","value":"The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits."},{"name":"\u200b","value":"The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers."},{"name":"\u200b","value":"Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H."},{"name":"\u200b","value":"The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:"},{"name":"\u200b","value":"JZ FARLABEL;"},{"name":"\u200b","value":"To accomplish this far jump, use the following two instructions:"},{"name":"\u200b","value":"JNZ BEYOND;"},{"name":"\u200b","value":"JMP FARLABEL;"},{"name":"\u200b","value":"BEYOND:"},{"name":"\u200b","value":"The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times)."},{"name":"\u200b","value":"All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability."},{"name":"\u200b","value":"In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits."}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}