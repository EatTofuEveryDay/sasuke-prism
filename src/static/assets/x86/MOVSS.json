{"title":"MOVSS — Move or Merge Scalar Single-Precision Floating-Point Value","fields":[{"name":"Instruction Modes","value":"`MOVSS xmm1, xmm2`\n`MOVSS xmm1, m32`\n`VMOVSS xmm1, xmm2, xmm3`\n`VMOVSS xmm1, m32`\n`MOVSS xmm2/m32, xmm1`\n`VMOVSS xmm1, xmm2, xmm3`\n`VMOVSS m32, xmm1`\n`VMOVSS xmm1 {k1}{z}, xmm2, xmm3`\n`VMOVSS xmm1 {k1}{z}, m32`\n`VMOVSS xmm1 {k1}{z}, xmm2, xmm3`\n`VMOVSS m32 {k1}, xmm1`"},{"name":"Description","value":"Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations."},{"name":"\u200b","value":"Legacy version: When the source and destination operands are XMM registers, bits (MAXVL-1:32) of the corresponding destination register are unmodified. When the source operand is a memory location and destination operand is an XMM registers, Bits (127:32) of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged."},{"name":"\u200b","value":"VEX and EVEX encoded register-register syntax: Moves a scalar single-precision floating-point value from the second source operand (the third operand) to the low doubleword element of the destination operand (the first operand). Bits 127:32 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed."},{"name":"\u200b","value":"VEX and EVEX encoded memory load syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:32 of the destination operand is cleared to all 0s."},{"name":"\u200b","value":"EVEX encoded versions: The low doubleword of the destination is updated according to the writemask."},{"name":"\u200b","value":"Note: For memory store form instruction “VMOVSS m32, xmm1”, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD. For memory store form instruction “VMOVSS mv {k1}, xmm1”, EVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD."},{"name":"\u200b","value":"Software should ensure VMOVSS is encoded with VEX.L=0. Encoding VMOVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."},{"name":"C/C++ Intrinsics","value":"`VMOVSS __m128 _mm_mask_load_ss(__m128 s, __mmask8 k, float * p);\n`"},{"name":"\u200b","value":"`VMOVSS __m128 _mm_maskz_load_ss( __mmask8 k, float * p);\n`"},{"name":"\u200b","value":"`VMOVSS __m128 _mm_mask_move_ss(__m128 sh, __mmask8 k, __m128 sl, __m128 a);\n`"},{"name":"\u200b","value":"`VMOVSS __m128 _mm_maskz_move_ss( __mmask8 k, __m128 s, __m128 a);\n`"},{"name":"\u200b","value":"`VMOVSS void _mm_mask_store_ss(float * p, __mmask8 k, __m128 a);\n`"},{"name":"\u200b","value":"`MOVSS __m128 _mm_load_ss(float * p)\n`"},{"name":"\u200b","value":"`MOVSS void_mm_store_ss(float * p, __m128 a)\n`"},{"name":"\u200b","value":"`MOVSS __m128 _mm_move_ss(__m128 a, __m128 b)\n`"},{"name":"CPUID Flags","value":"SSE"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}