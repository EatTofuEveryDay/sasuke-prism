{"title":"ADC — Add with Carry","fields":[{"name":"Instruction Modes","value":"`ADC AL, imm8`\n`ADC AX, imm16`\n`ADC EAX, imm32`\n`ADC RAX, imm32`\n`ADC r/m8, imm8`\n`ADC r/m8*, imm8`\n`ADC r/m16, imm16`\n`ADC r/m32, imm32`\n`ADC r/m64, imm32`\n`ADC r/m16, imm8`\n`ADC r/m32, imm8`\n`ADC r/m64, imm8`\n`ADC r/m8, r8`\n`ADC r/m8*, r8*`\n`ADC r/m16, r16`\n`ADC r/m32, r32`\n`ADC r/m64, r64`\n`ADC r8, r/m8`\n`ADC r8*, r/m8*`\n`ADC r16, r/m16`\n`ADC r32, r/m32`\n`ADC r64, r/m64`"},{"name":"Description","value":"Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format."},{"name":"\u200b","value":"The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result."},{"name":"\u200b","value":"The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction."},{"name":"\u200b","value":"This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically."},{"name":"\u200b","value":"In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits."},{"name":"C/C++ Intriniscs","value":"`ADC: extern unsigned char _addcarry_u8(unsigned char c_in, unsigned char src1, unsigned char src2, unsigned char *sum_out);\n`"},{"name":"\u200b","value":"`ADC: extern unsigned char _addcarry_u16(unsigned char c_in, unsigned short src1, unsigned short src2, unsigned short *sum_out);\n`"},{"name":"\u200b","value":"`ADC: extern unsigned char _addcarry_u32(unsigned char c_in, unsigned int src1, unsigned char int, unsigned int *sum_out);\n`"},{"name":"\u200b","value":"`ADC: extern unsigned char _addcarry_u64(unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);\n`"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}