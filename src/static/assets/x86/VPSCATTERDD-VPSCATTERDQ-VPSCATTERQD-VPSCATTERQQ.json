{"title":"VPSCATTERDD/VPSCATTERDQ/VPSCATTERQD/VPSCATTERQQ â€” Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices","fields":[{"name":"Instruction Modes","value":"`VPSCATTERDD vm32x {k1}, xmm1`\n`VPSCATTERDD vm32y {k1}, ymm1`\n`VPSCATTERDD vm32z {k1}, zmm1`\n`VPSCATTERDQ vm32x {k1}, xmm1`\n`VPSCATTERDQ vm32x {k1}, ymm1`\n`VPSCATTERDQ vm32y {k1}, zmm1`\n`VPSCATTERQD vm64x {k1}, xmm1`\n`VPSCATTERQD vm64y {k1}, xmm1`\n`VPSCATTERQD vm64z {k1}, ymm1`\n`VPSCATTERQQ vm64x {k1}, xmm1`\n`VPSCATTERQQ vm64y {k1}, ymm1`\n`VPSCATTERQQ vm64z {k1}, zmm1`"},{"name":"Description","value":"Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception."},{"name":"\u200b","value":"This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued."},{"name":"\u200b","value":"Note that:"},{"name":"C/C++ Intriniscs","value":"`VPSCATTERDD void _mm512_i32scatter_epi32(void * base, __m512i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDD void _mm256_i32scatter_epi32(void * base, __m256i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDD void _mm_i32scatter_epi32(void * base, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDD void _mm512_mask_i32scatter_epi32(void * base, __mmask16 k, __m512i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDD void _mm256_mask_i32scatter_epi32(void * base, __mmask8 k, __m256i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDD void _mm_mask_i32scatter_epi32(void * base, __mmask8 k, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm512_i32scatter_epi64(void * base, __m256i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm256_i32scatter_epi64(void * base, __m128i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm_i32scatter_epi64(void * base, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm512_mask_i32scatter_epi64(void * base, __mmask8 k, __m256i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm256_mask_i32scatter_epi64(void * base, __mmask8 k, __m128i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERDQ void _mm_mask_i32scatter_epi64(void * base, __mmask8 k, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm512_i64scatter_epi32(void * base, __m512i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm256_i64scatter_epi32(void * base, __m256i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm_i64scatter_epi32(void * base, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm512_mask_i64scatter_epi32(void * base, __mmask8 k, __m512i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm256_mask_i64scatter_epi32(void * base, __mmask8 k, __m256i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQD void _mm_mask_i64scatter_epi32(void * base, __mmask8 k, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm512_i64scatter_epi64(void * base, __m512i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm256_i64scatter_epi64(void * base, __m256i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm_i64scatter_epi64(void * base, __m128i vdx, __m128i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm512_mask_i64scatter_epi64(void * base, __mmask8 k, __m512i vdx, __m512i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm256_mask_i64scatter_epi64(void * base, __mmask8 k, __m256i vdx, __m256i a, int scale);\n`"},{"name":"\u200b","value":"`VPSCATTERQQ void _mm_mask_i64scatter_epi64(void * base, __mmask8 k, __m128i vdx, __m128i a, int scale);\n`"},{"name":"CPUID Flags","value":"AVX512VL AVX512F"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}