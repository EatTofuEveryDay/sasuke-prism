{"title":"VPGATHERDD/VPGATHERDQ — Gather Packed Dword, Packed Qword with Signed Dword Indices","fields":[{"name":"Instruction Modes","value":"`VPGATHERDD xmm1 {k1}, vm32x`\n`VPGATHERDD ymm1 {k1}, vm32y`\n`VPGATHERDD zmm1 {k1}, vm32z`\n`VPGATHERDQ xmm1 {k1}, vm32x`\n`VPGATHERDQ ymm1 {k1}, vm32x`\n`VPGATHERDQ zmm1 {k1}, vm32y`"},{"name":"Description","value":"A set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register (zmm1) is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception."},{"name":"\u200b","value":"This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued."},{"name":"\u200b","value":"If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements."},{"name":"\u200b","value":"Note that:"},{"name":"C/C++ Intrinsics","value":"`VPGATHERDD __m512i _mm512_i32gather_epi32( __m512i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDD __m512i _mm512_mask_i32gather_epi32(__m512i s, __mmask16 k, __m512i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDD __m256i _mm256_mmask_i32gather_epi32(__m256i s, __mmask8 k, __m256i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDD __m128i _mm_mmask_i32gather_epi32(__m128i s, __mmask8 k, __m128i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDQ __m512i _mm512_i32logather_epi64( __m256i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDQ __m512i _mm512_mask_i32logather_epi64(__m512i s, __mmask8 k, __m256i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDQ __m256i _mm256_mmask_i32logather_epi64(__m256i s, __mmask8 k, __m128i vdx, void * base, int scale);\n`"},{"name":"\u200b","value":"`VPGATHERDQ __m128i _mm_mmask_i32gather_epi64(__m128i s, __mmask8 k, __m128i vdx, void * base, int scale);\n`"},{"name":"CPUID Flags","value":"AVX512VL AVX512F"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}