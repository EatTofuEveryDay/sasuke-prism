{"title":"VRNDSCALEPS — Round Packed Float32 Values To Include A Given Number Of Fraction Bits","fields":[{"name":"Instruction Modes","value":"`ib VRNDSCALEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8`\n`ib VRNDSCALEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8`\n`ib VRNDSCALEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8`"},{"name":"Description","value":"Round the single-precision floating-point values in the source operand by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the destination operand."},{"name":"\u200b","value":"The destination operand (the first operand) is a ZMM register conditionally updated according to the writemask. The source operand (the second operand) can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location."},{"name":"\u200b","value":"The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value."},{"name":"\u200b","value":"It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value)."},{"name":"\u200b","value":"The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field)."},{"name":"\u200b","value":"The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding."},{"name":"\u200b","value":"The sign of the result of this instruction is preserved, including the sign of zero."},{"name":"\u200b","value":"The formula of the operation on each data element for VRNDSCALEPS is"},{"name":"\u200b","value":"ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"M=imm[7:4];"},{"name":"\u200b","value":"The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs)."},{"name":"\u200b","value":"VRNDSCALEPS is a more general form of the VEX-encoded VROUNDPS instruction. In VROUNDPS, the formula of the operation on each element is"},{"name":"\u200b","value":"ROUND(x) = Round_to_INT(x, round_ctrl),"},{"name":"\u200b","value":"round_ctrl = imm[3:0];"},{"name":"\u200b","value":"Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."},{"name":"\u200b","value":"Handling of special case of input values are listed in Table 5-25."},{"name":"C/C++ Intriniscs","value":"`VRNDSCALEPS __m512 _mm512_roundscale_ps( __m512 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m512 _mm512_roundscale_round_ps( __m512 a, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m512 _mm512_mask_roundscale_ps(__m512 s, __mmask16 k, __m512 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m512 _mm512_mask_roundscale_round_ps(__m512 s, __mmask16 k, __m512 a, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m512 _mm512_maskz_roundscale_ps( __mmask16 k, __m512 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m512 _mm512_maskz_roundscale_round_ps( __mmask16 k, __m512 a, int imm, int sae);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m256 _mm256_roundscale_ps( __m256 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m256 _mm256_mask_roundscale_ps(__m256 s, __mmask8 k, __m256 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m256 _mm256_maskz_roundscale_ps( __mmask8 k, __m256 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m128 _mm_roundscale_ps( __m256 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m128 _mm_mask_roundscale_ps(__m128 s, __mmask8 k, __m128 a, int imm);\n`"},{"name":"\u200b","value":"`VRNDSCALEPS __m128 _mm_maskz_roundscale_ps( __mmask8 k, __m128 a, int imm);\n`"},{"name":"CPUID Flags","value":"AVX512VL AVX512F"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}