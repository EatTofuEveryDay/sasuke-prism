{"title":"VCVTSS2USI — Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer","fields":[{"name":"Instruction Modes","value":"`VCVTSS2USI r32, xmm1/m32{er}`\n`VCVTSS2USI r64, xmm1/m32{er}`"},{"name":"Description","value":"Converts a single-precision floating-point value in the source operand (the second operand) to an unsigned double-word integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register."},{"name":"\u200b","value":"When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format."},{"name":"\u200b","value":"VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode."},{"name":"\u200b","value":"Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`VCVTSS2USI unsigned _mm_cvtss_u32( __m128 a);\n`"},{"name":"\u200b","value":"`VCVTSS2USI unsigned _mm_cvt_roundss_u32( __m128 a, int r);\n`"},{"name":"\u200b","value":"`VCVTSS2USI unsigned __int64 _mm_cvtss_u64( __m128 a);\n`"},{"name":"\u200b","value":"`VCVTSS2USI unsigned __int64 _mm_cvt_roundss_u64( __m128 a, int r);\n`"},{"name":"CPUID Flags","value":"AVX512F"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}