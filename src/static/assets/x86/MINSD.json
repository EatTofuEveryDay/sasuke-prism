{"title":"MINSD â€” Return Minimum Scalar Double-Precision Floating-Point Value","fields":[{"name":"Instruction Modes","value":"`MINSD xmm1, xmm2/m64`\n`VMINSD xmm1, xmm2, xmm3/m64`\n`VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}`"},{"name":"Description","value":"Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed."},{"name":"\u200b","value":"If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned)."},{"name":"\u200b","value":"If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR."},{"name":"\u200b","value":"The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers."},{"name":"\u200b","value":"128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged."},{"name":"\u200b","value":"VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed."},{"name":"\u200b","value":"EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask."},{"name":"\u200b","value":"Software should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."},{"name":"C/C++ Intrinsics","value":"`VMINSD __m128d _mm_min_round_sd(__m128d a, __m128d b, int);\n`"},{"name":"\u200b","value":"`VMINSD __m128d _mm_mask_min_round_sd(__m128d s, __mmask8 k, __m128d a, __m128d b, int);\n`"},{"name":"\u200b","value":"`VMINSD __m128d _mm_maskz_min_round_sd( __mmask8 k, __m128d a, __m128d b, int);\n`"},{"name":"\u200b","value":"`MINSD __m128d _mm_min_sd(__m128d a, __m128d b)\n`"},{"name":"CPUID Flags","value":"SSE2"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}