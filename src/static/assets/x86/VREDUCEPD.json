{"title":"VREDUCEPD — Perform Reduction Transformation on Packed Float64 Values","fields":[{"name":"Instruction Modes","value":"`ib VREDUCEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8`\n`ib VREDUCEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8`\n`ib VREDUCEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8`"},{"name":"Description","value":"Perform reduction transformation of the packed binary encoded double-precision FP values in the source operand (the second operand) and store the reduced results in binary FP format to the destination operand (the first operand) under the writemask k1."},{"name":"\u200b","value":"The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:"},{"name":"\u200b","value":"dest = src – (ROUND(2M*src))*2-M;"},{"name":"\u200b","value":"where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents."},{"name":"\u200b","value":"The magnitude of the reduced result can be expressed by considering src= 2p*man2,"},{"name":"\u200b","value":"where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent"},{"name":"\u200b","value":"Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1"},{"name":"\u200b","value":"Then if RC ≠ RNE: 0&lt;=|Reduced Result|&lt;2p-M"},{"name":"\u200b","value":"This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported."},{"name":"\u200b","value":"EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`VREDUCEPD __m512d _mm512_mask_reduce_pd( __m512d a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m512d _mm512_mask_reduce_pd(__m512d s, __mmask8 k, __m512d a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m512d _mm512_maskz_reduce_pd(__mmask8 k, __m512d a, int imm, int sae)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m256d _mm256_mask_reduce_pd( __m256d a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m256d _mm256_mask_reduce_pd(__m256d s, __mmask8 k, __m256d a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m256d _mm256_maskz_reduce_pd(__mmask8 k, __m256d a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m128d _mm_mask_reduce_pd( __m128d a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m128d _mm_mask_reduce_pd(__m128d s, __mmask8 k, __m128d a, int imm)\n`"},{"name":"\u200b","value":"`VREDUCEPD __m128d _mm_maskz_reduce_pd(__mmask8 k, __m128d a, int imm)\n`"},{"name":"CPUID Flags","value":"AVX512VL AVX512DQ"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}