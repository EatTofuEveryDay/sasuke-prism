{"title":"EXTRACTPS â€” Extract Packed Floating-Point Values","fields":[{"name":"Instruction Modes","value":"`ib EXTRACTPS reg/m32, xmm1, imm8`\n`ib VEXTRACTPS reg/m32, xmm1, imm8`\n`ib VEXTRACTPS reg/m32, xmm1, imm8`"},{"name":"Description","value":"Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored."},{"name":"\u200b","value":"The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand"},{"name":"\u200b","value":"In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored."},{"name":"\u200b","value":"VEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits."},{"name":"\u200b","value":"VEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."},{"name":"\u200b","value":"128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits."},{"name":"\u200b","value":"The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the 32-bit floating-point value."},{"name":"\u200b","value":"If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."},{"name":"C/C++ Intriniscs","value":"`EXTRACTPS int _mm_extract_ps (__m128 a, const int nidx);\n`"},{"name":"CPUID Flags","value":"SSE4_1"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}