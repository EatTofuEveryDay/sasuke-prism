{"title":"ANDN â€” Logical AND NOT","fields":[{"name":"Instruction Modes","value":"`ANDN r32a, r32b, r/m32`\n`ANDN r64a, r64b, r/m64`"},{"name":"Description","value":"Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the"},{"name":"\u200b","value":"second source operand). The result is stored in the first operand (destination operand)."},{"name":"\u200b","value":"This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD."},{"name":"C/C++ Intrinsics","value":"`Auto-generated from high-level language.\n`"},{"name":"CPUID Flags","value":"BMI1"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}