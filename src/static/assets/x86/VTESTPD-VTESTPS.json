{"title":"VTESTPD/VTESTPS â€” Packed Bit Test","fields":[{"name":"Instruction Modes","value":"`VTESTPS xmm1, xmm2/m128`\n`VTESTPS ymm1, ymm2/m256`\n`VTESTPD xmm1, xmm2/m128`\n`VTESTPD ymm1, ymm2/m256`"},{"name":"Description","value":"VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD."},{"name":"\u200b","value":"VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD."},{"name":"\u200b","value":"The first source register is specified by the ModR/M reg field."},{"name":"\u200b","value":"128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified."},{"name":"\u200b","value":"VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified."},{"name":"\u200b","value":"Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."},{"name":"C/C++ Intrinsics","value":"`<strong>VTESTPS</strong> int _mm256_testz_ps (__m256 s1, __m256 s2);\n`"},{"name":"\u200b","value":"`int _mm256_testc_ps (__m256 s1, __m256 s2);\n`"},{"name":"\u200b","value":"`int _mm256_testnzc_ps (__m256 s1, __m128 s2);\n`"},{"name":"\u200b","value":"`int _mm_testz_ps (__m128 s1, __m128 s2);\n`"},{"name":"\u200b","value":"`int _mm_testc_ps (__m128 s1, __m128 s2);\n`"},{"name":"\u200b","value":"`int _mm_testnzc_ps (__m128 s1, __m128 s2);\n`"},{"name":"\u200b","value":"`<strong>VTESTPD</strong> int _mm256_testz_pd (__m256d s1, __m256d s2);\n`"},{"name":"\u200b","value":"`int _mm256_testc_pd (__m256d s1, __m256d s2);\n`"},{"name":"\u200b","value":"`int _mm256_testnzc_pd (__m256d s1, __m256d s2);\n`"},{"name":"\u200b","value":"`int _mm_testz_pd (__m128d s1, __m128d s2);\n`"},{"name":"\u200b","value":"`int _mm_testc_pd (__m128d s1, __m128d s2);\n`"},{"name":"\u200b","value":"`int _mm_testnzc_pd (__m128d s1, __m128d s2);\n`"},{"name":"CPUID Flags","value":"AVX"}],"color":65535,"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}