{"title":"PBLENDVB — Variable Blend Packed Bytes","fields":[{"name":"Instruction Modes","value":"`PBLENDVB xmm1, xmm2/m128, &lt;XMM0&gt;`\n`/is4 VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4`\n`/is4 VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4`"},{"name":"Description","value":"Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register."},{"name":"\u200b","value":"If a mask bit is “1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged."},{"name":"\u200b","value":"The register assignment of the implicit third operand is defined to be the architectural register XMM0."},{"name":"\u200b","value":"128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD."},{"name":"\u200b","value":"VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD."},{"name":"\u200b","value":"VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored."},{"name":"\u200b","value":"VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception."},{"name":"C/C++ Intriniscs","value":"`(V)PBLENDVB: __m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask);\n`"},{"name":"\u200b","value":"`VPBLENDVB: __m256i _mm256_blendv_epi8 (__m256i v1, __m256i v2, __m256i mask);\n`"},{"name":"CPUID Flags","value":"SSE4_1"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}