{"title":"PEXTRB/PEXTRD/PEXTRQ — Extract Byte/Dword/Qword","fields":[{"name":"Instruction Modes","value":"`ib PEXTRB reg/m8, xmm2, imm8`\n`ib PEXTRD r/m32, xmm2, imm8`\n`ib PEXTRQ r/m64, xmm2, imm8`\n`ib VPEXTRB reg/m8, xmm2, imm8`\n`ib VPEXTRD r32/m32, xmm2, imm8`\n`ib VPEXTRQ r64/m64, xmm2, imm8`\n`ib VPEXTRB reg/m8, xmm2, imm8`\n`ib VPEXTRD r32/m32, xmm2, imm8`\n`ib VPEXTRQ r64/m64, xmm2, imm8`"},{"name":"Description","value":"Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended."},{"name":"\u200b","value":"In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode."},{"name":"\u200b","value":"Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be"},{"name":"\u200b","value":"0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros."},{"name":"C/C++ Intriniscs","value":"`PEXTRB: int _mm_extract_epi8 (__m128i src, const int ndx);\n`"},{"name":"\u200b","value":"`PEXTRD: int _mm_extract_epi32 (__m128i src, const int ndx);\n`"},{"name":"\u200b","value":"`PEXTRQ: __int64 _mm_extract_epi64 (__m128i src, const int ndx);\n`"},{"name":"CPUID Flags","value":"SSE4_1"}],"footer":{"text":"Thanks to Felix Cloutier for the online x86 reference"}}